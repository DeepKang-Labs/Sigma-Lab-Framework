name: Sigma-Dynamics (ingest & visualize)

on:
  workflow_dispatch:
    inputs:
      prompt:
        description: "Prompt one-shot pour Sigma-LLM"
        required: false
        default: "Diagnostic quotidien : état réseau & marché."
      model_name:
        description: "Modèle HF (ex: gpt2, TinyLlama/TinyLlama-1.1B-Chat-v1.0, etc.)"
        required: false
        default: "gpt2"
  schedule:
    - cron: "21 4 * * *"  # chaque jour à 04:21 UTC (optionnel)

permissions:
  contents: write        # commit des CSV/PNG
  pages: write
  id-token: write

concurrency:
  group: sigma-llm-${{ github.ref }}
  cancel-in-progress: false

jobs:
  run:
    runs-on: ubuntu-latest

    env:
      SIGMA_CONFIGS_DIR: configs
      SIGMA_STATE_DIR: state
      SIGMA_REPORTS_DIR: reports
      SIGMA_OUTPUTS_DIR: outputs
      PROM_JOB: "sigma_llm_ci"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip wheel setuptools
          pip install --index-url https://download.pytorch.org/whl/cpu torch
          pip install "transformers>=4.42" "accelerate>=0.33" "tqdm" "numpy" "matplotlib" "prometheus-client"
          # Note: pas d'installation de faiss / sentence-transformers ici

      - name: Ensure dirs exist
        run: |
          mkdir -p "$SIGMA_CONFIGS_DIR" "$SIGMA_STATE_DIR" "$SIGMA_REPORTS_DIR" "$SIGMA_OUTPUTS_DIR"
          mkdir -p sigma/core
          [ -f sigma/__init__.py ] || echo "" > sigma/__init__.py
          [ -f sigma/core/__init__.py ] || echo "" > sigma/core/__init__.py

      - name: Write lightweight core (no-faiss, no sentence-transformers)
        shell: bash
        run: |
          cat > sigma/core/semantic_index.py <<'PY'
          import math, json, time, os
          from typing import List, Tuple, Any, Dict
          def _cosine(a: List[float], b: List[float], eps: float = 1e-9) -> float:
              dot = sum(x*y for x, y in zip(a, b))
              na = math.sqrt(sum(x*x for x in a)); nb = math.sqrt(sum(y*y for y in b))
              return 0.0 if na*nb < eps else dot/(na*nb)
          class SemanticIndex:
              def __init__(self, path: str = os.path.join(os.getenv("SIGMA_STATE_DIR","state"), "semantic_index.jsonl"),
                           max_items: int = 2000, min_similarity_to_store: float = 0.15):
                  self.path, self.max_items, self.min_sim = path, int(max_items), float(min_similarity_to_store)
                  self.items: List[Dict[str, Any]] = []
                  try:
                      with open(self.path, "r", encoding="utf-8") as f:
                          for line in f: self.items.append(json.loads(line))
                  except Exception: pass
              def query(self, embedding: List[float], k: int = 5) -> List[Tuple[float, str]]:
                  scored = [(_cosine(embedding, it["emb"]), it["text"]) for it in self.items if "emb" in it]
                  scored.sort(reverse=True); return scored[:k]
              def add(self, embedding: List[float], text: str):
                  if self.items:
                      best = max((_cosine(embedding, it["emb"]) for it in self.items if "emb" in it), default=0.0)
                      if best >= self.min_sim: return
                  self.items.append({"t": int(time.time()), "emb": embedding, "text": text})
                  if len(self.items) > self.max_items: self.items = self.items[-self.max_items:]
                  with open(self.path, "w", encoding="utf-8") as f:
                      for it in self.items: f.write(json.dumps(it, ensure_ascii=False) + "\n")
          PY

          cat > sigma/core/rag.py <<'PY'
          from typing import List, Dict, Any
          # RAG ultra-léger: renvoie 0 ou 1 passage fictif si aucune base locale
          def retrieve_topk(query: str, k: int = 3) -> List[Dict[str, Any]]:
              base = []  # brancher ici une base locale si besoin
              if not base:
                  return [{"score": 0.0, "text": ""}]
              return [{"score": 1.0, "text": t} for t in base][:k]
          PY

          cat > sigma/core/judge.py <<'PY'
          from typing import List, Dict, Any
          # Heuristiques légères pour CI
          def judge_factuality(prompt: str, output: str, passages: List[Dict[str, Any]]) -> Dict[str, Any]:
              score = 0.7
              if "??" in output or "lorem" in output.lower(): score = 0.4
              return {"score": score, "evidence": passages[:3]}
          def judge_coherence(text: str) -> Dict[str, Any]:
              score = 0.8 if len(text.split()) > 5 else 0.5
              return {"score": score}
          PY

      - name: Maybe generate Sigma-LLM report (fallback)
        shell: bash
        env:
          PYTHONPATH: ${{ github.workspace }}
          PROMPT_IN: ${{ github.event.inputs.prompt }}
          MODEL_IN:  ${{ github.event.inputs.model_name }}
        run: |
          set -e
          PROMPT="${PROMPT_IN:-Diagnostic quotidien : état réseau & marché.}"
          MODEL="${MODEL_IN:-gpt2}"

          python - <<'PY'
          import os, importlib.util, pathlib, json, time, sys
          ROOT = pathlib.Path(".")
          patterns = ["sigma_llm_complete.py","sigmacomplettllm.py","sigma_llm*.py","SigmaLLM*.py"]
          found=[]
          for patt in patterns: found += [str(p) for p in ROOT.glob(patt)]
          if not found:
              print("::warning:: Aucun script Sigma-LLM trouvé — on continue (les visuels utiliseront les valeurs par défaut).")
              sys.exit(0)
          script = sorted(found)[0]
          spec = importlib.util.spec_from_file_location("sigma_llm_mod", script)
          mod  = importlib.util.module_from_spec(spec)
          spec.loader.exec_module(mod)

          if not hasattr(mod,"SigmaLLM"):
              print("::error:: Classe SigmaLLM introuvable"); sys.exit(2)

          prompt = os.getenv("PROMPT_IN","Diagnostic quotidien : état réseau & marché.")
          model  = os.getenv("MODEL_IN","gpt2")
          agent  = mod.SigmaLLM(model_name=model)
          _ = agent.generate(prompt)

          rp = os.getenv("SIGMA_REPORTS_DIR","reports")
          pathlib.Path(rp).mkdir(parents=True, exist_ok=True)
          last = pathlib.Path(rp)/"sigma_llm_last_report.json"
          if last.exists():
              print("Report generated:", last)
          else:
              print("::warning:: Pas de last_report écrit par le script.")
          PY

      - name: Build Sigma-Dynamics CSV and Plot
        shell: python
        run: |
          import os, json, csv, pathlib, time
          import matplotlib.pyplot as plt

          RP = pathlib.Path(os.getenv("SIGMA_REPORTS_DIR","reports"))
          RP.mkdir(parents=True, exist_ok=True)
          last = RP/"sigma_llm_last_report.json"
          out_csv = RP/"sigma_dynamics.csv"
          out_png = RP/"sigma_dynamics.png"

          data = {"t": int(time.time()), "delta_coh": 0.0, "S": 0.0, "O": 0.0,
                  "entropy": 0.0, "temp": 1.0, "top_p": 0.95}
          if last.exists():
              try: data.update(json.load(open(last)))
              except Exception as e: print("warn:", e)

          headers = ["t","delta_coh","S","O","entropy","temp","top_p"]
          write_header = not out_csv.exists()
          with open(out_csv,"a", newline="") as f:
              w=csv.DictWriter(f, fieldnames=headers)
              if write_header: w.writeheader()
              w.writerow({k:data.get(k) for k in headers})

          xs = []
          ys_S, ys_O = [], []
          with open(out_csv) as f:
              r=csv.DictReader(f)
              for row in r:
                  xs.append(int(row["t"]))
                  ys_S.append(float(row["S"]))
                  ys_O.append(float(row["O"]))

          if xs:
              plt.figure(figsize=(8,4))
              plt.plot(xs, ys_S, label="S(t)")
              plt.plot(xs, ys_O, label="O(t)")
              plt.legend(); plt.title("Sigma Dynamics — S(t) / O(t)")
              plt.xlabel("timestamp"); plt.ylabel("value")
              plt.tight_layout(); plt.savefig(out_png); plt.close()

          print("CSV:", out_csv); print("PNG:", out_png)

      - name: Job Summary
        shell: bash
        run: |
          echo "## Sigma-Dynamics" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "- CSV: \`reports/sigma_dynamics.csv\`" >> "$GITHUB_STEP_SUMMARY"
          echo "- PNG: \`reports/sigma_dynamics.png\`" >> "$GITHUB_STEP_SUMMARY"

      - name: Commit CSV/PNG to repo
        shell: bash
        run: |
          set -e
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add reports/sigma_dynamics.csv reports/sigma_dynamics.png || true
          if ! git diff --cached --quiet; then
            git commit -m "chore(ci): update sigma dynamics CSV/PNG"
            git push
          else
            echo "No changes to commit."
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sigma_dynamics_${{ github.run_id }}_${{ github.run_number }}
          path: |
            reports/sigma_dynamics.csv
            reports/sigma_dynamics.png
            reports/sigma_llm_last_report.json
          if-no-files-found: warn
          retention-days: 14
