#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Bridge Skywire → Sigma
- Lit un skywire_vitals.json brut
- Sanitize (retrait champs sensibles éventuels)
- Produit un mini rapport Markdown
- Transforme vers un payload Sigma enrichi (metrics réseau + supply)
- Écrit les sorties dans les chemins fournis

Usage (exemple) :
  python scripts/bridge.py \
      --in data/2025-10-30/skywire_vitals.json \
      --out reports/2025-10-30/skywire_vitals_sanitized.json \
      --md  reports/2025-10-30/skywire_vital_report.md \
      --sigma reports/2025-10-30/skywire_sigma_analysis.json
"""

from __future__ import annotations
import argparse
import json
import os
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple


# ----------------------------
# Helpers
# ----------------------------

SUSPECT_KEYS = {"ip", "public_key", "debug"}  # clés potentiellement sensibles au top-level


def to_float(x: Any, default: float = 0.0) -> float:
    try:
        if x is None:
            return default
        if isinstance(x, (int, float)):
            return float(x)
        s = str(x).strip()
        if s == "":
            return default
        return float(s)
    except Exception:
        return default


def ensure_parent(path: Path) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)


def load_json(path: Path) -> Dict[str, Any]:
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)


def write_json(path: Path, obj: Any) -> None:
    ensure_parent(path)
    with path.open("w", encoding="utf-8") as f:
        json.dump(obj, f, ensure_ascii=False, indent=2)


def write_text(path: Path, text: str) -> None:
    ensure_parent(path)
    with path.open("w", encoding="utf-8") as f:
        f.write(text)


# ----------------------------
# Sanitize & Quick report
# ----------------------------

def sanitize_top_level(data: Dict[str, Any]) -> Dict[str, Any]:
    """Retire quelques clés sensibles (si présentes) au niveau racine uniquement."""
    out = dict(data)
    for k in list(out.keys()):
        if k in SUSPECT_KEYS:
            out.pop(k, None)
    return out


@dataclass
class QuickCounts:
    groups: int
    endpoints_total: int
    payloads_total: int
    ok: int
    failed: int


def quick_counts_from_data(data: Dict[str, Any]) -> QuickCounts:
    groups = data.get("groups", []) or []
    endpoints_total = 0
    payloads_total = 0
    ok = 0
    failed = 0

    for g in groups:
        endpoints = g.get("endpoints", []) or []
        payloads = g.get("payloads", []) or []
        endpoints_total += len(endpoints)
        payloads_total += len(payloads)
        for p in payloads:
            if bool(p.get("_ok_")) and p.get("_status_") == 200:
                ok += 1
            else:
                failed += 1

    return QuickCounts(
        groups=len(groups),
        endpoints_total=endpoints_total,
        payloads_total=payloads_total,
        ok=ok,
        failed=failed,
    )


def infer_date_utc(data: Dict[str, Any]) -> str:
    return data.get("date_utc") or datetime.utcnow().isoformat() + "Z"


def render_markdown_report(date_utc: str, counts: QuickCounts, notes: Optional[str] = None) -> str:
    availability = 0.0
    if counts.payloads_total:
        availability = round(100.0 * counts.ok / counts.payloads_total, 2)

    lines = [
        f"# Skywire Vital Report ({date_utc})",
        "",
        f"- **Groups**: {counts.groups}",
        f"- **Endpoints (total)**: {counts.endpoints_total}",
        f"- **Payloads**: {counts.payloads_total} — ✅ {counts.ok} / ❌ {counts.failed}",
        f"- **Availability**: {availability} %",
    ]
    if notes:
        lines += ["", f"> {notes}"]
    lines += ["", "_Auto-generated by bridge.py_"]
    return "\n".join(lines)


# ----------------------------
# Transform → Sigma
# ----------------------------

def transform_to_sigma(data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Convertit les données brutes skywire_vitals → format Sigma enrichi.
    Extrait :
      - current_supply / total_supply / coin_hours_total (si présents dans summary d’un groupe)
      - métriques réseau (endpoints, payloads ok/failed, disponibilité)
    """
    sigma_payload: Dict[str, Any] = {}
    metrics: Dict[str, Any] = {}

    # 1) Informations de base
    meta = data.get("meta", {}) or {}
    sigma_payload["date_utc"] = infer_date_utc(data)
    sigma_payload["meta"] = {
        "source": meta.get("repo", "unknown"),
        "agent": meta.get("agent", "unknown"),
    }

    # 2) Agrégats réseau + extraction summary (s’il existe)
    groups = data.get("groups", []) or []
    total_endpoints = 0
    total_payloads = 0
    ok_payloads = 0
    failed_payloads = 0

    for g in groups:
        endpoints = g.get("endpoints", []) or []
        payloads = g.get("payloads", []) or []
        total_endpoints += len(endpoints)
        total_payloads += len(payloads)
        for p in payloads:
            if bool(p.get("_ok_")) and p.get("_status_") == 200:
                ok_payloads += 1
            else:
                failed_payloads += 1
        # Summary blockchain (ex: groupe "explorer")
        if isinstance(g.get("summary"), dict):
            summary = g["summary"]
            metrics["current_supply"] = to_float(summary.get("current_supply"))
            metrics["total_supply"] = to_float(summary.get("total_supply"))
            metrics["coin_hours_total"] = to_float(summary.get("coin_hours"))

    metrics["groups_detected"] = len(groups)
    metrics["endpoints_total"] = total_endpoints
    metrics["payloads_total"] = total_payloads
    metrics["payloads_ok"] = ok_payloads
    metrics["payloads_failed"] = failed_payloads
    metrics["availability_ratio_%"] = (
        round(100.0 * ok_payloads / total_payloads, 2) if total_payloads else 0.0
    )

    sigma_payload["metrics"] = metrics
    sigma_payload["notes"] = "Bridge Skywire → Sigma : endpoints & supply aggregated."

    return sigma_payload


# ----------------------------
# Main pipeline
# ----------------------------

def run_bridge(in_path: Path, out_sanitized: Path, out_md: Path, out_sigma: Path) -> None:
    # 1) Charge
    raw = load_json(in_path)

    # 2) Sanitize (léger)
    sanitized = sanitize_top_level(raw)

    # 3) Quick report
    counts = quick_counts_from_data(sanitized)
    date_utc = infer_date_utc(sanitized)
    md = render_markdown_report(date_utc, counts)

    # 4) Transform → Sigma
    sigma = transform_to_sigma(sanitized)

    # 5) Écrit les sorties
    write_json(out_sanitized, sanitized)
    write_text(out_md, md)
    write_json(out_sigma, sigma)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Bridge Skywire → Sigma")
    parser.add_argument("--in", dest="in_path", required=True, help="Chemin du skywire_vitals.json brut")
    parser.add_argument("--out", dest="out_json", required=True, help="Chemin du JSON sanitizé")
    parser.add_argument("--md", dest="out_md", required=True, help="Chemin du rapport Markdown")
    parser.add_argument("--sigma", dest="out_sigma", required=True, help="Chemin du JSON Sigma")
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    in_path = Path(args.in_path)
    out_sanitized = Path(args.out_json)
    out_md = Path(args.out_md)
    out_sigma = Path(args.out_sigma)

    if not in_path.exists():
        raise FileNotFoundError(f"Input not found: {in_path}")

    run_bridge(in_path, out_sanitized, out_md, out_sigma)
    # Log minimal en sortie CI
    print(f"[bridge] OK →\n  sanitized: {out_sanitized}\n  report:    {out_md}\n  sigma:     {out_sigma}")


if __name__ == "__main__":
    main()
