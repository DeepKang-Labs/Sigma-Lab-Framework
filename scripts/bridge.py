#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Bridge: VitalSigns JSON  →  (sanitized JSON, quick MD)  +  Sigma transform JSON

Usage:
  python scripts/bridge.py --in data/2025-10-30/skywire_vitals.json \
                           --out reports/2025-10-30/skywire_vitals_sanitized.json \
                           --md  reports/2025-10-30/skywire_vital_report.md \
                           --sigma reports/2025-10-30/skywire_sigma_analysis.json
"""
from __future__ import annotations
import argparse, json, os, statistics, datetime, pathlib, sys
from typing import Any, Dict, List

def read_json(p: str) -> Dict[str, Any]:
    with open(p, "r", encoding="utf-8") as f:
        return json.load(f)

def write_json(obj: Any, p: str) -> None:
    pathlib.Path(os.path.dirname(p)).mkdir(parents=True, exist_ok=True)
    with open(p, "w", encoding="utf-8") as f:
        json.dump(obj, f, ensure_ascii=False, indent=2)

def write_text(txt: str, p: str) -> None:
    pathlib.Path(os.path.dirname(p)).mkdir(parents=True, exist_ok=True)
    with open(p, "w", encoding="utf-8") as f:
        f.write(txt)

SENSITIVE_TOPLEVEL = {"ip", "public_key", "debug", "signature"}

def sanitize_payload(doc: Dict[str, Any]) -> Dict[str, Any]:
    """Drop known sensitive keys; keep structure stable."""
    clean = json.loads(json.dumps(doc))  # deep copy
    for k in list(clean.keys()):
        if k in SENSITIVE_TOPLEVEL:
            clean.pop(k, None)
    # prune sensitive keys inside groups/payloads if any appear
    for g in clean.get("groups", []) or []:
        for pl in g.get("payloads", []) or []:
            for k in list(pl.keys()):
                if k in SENSITIVE_TOPLEVEL:
                    pl.pop(k, None)
    return clean

def metrics_from(doc: Dict[str, Any]) -> Dict[str, Any]:
    """Extract simple, robust metrics from VitalSigns shape."""
    success_flags: List[bool] = []
    latencies: List[float] = []

    for g in (doc.get("groups") or []):
        for pl in (g.get("payloads") or []):
            ok = pl.get("__ok__")
            if isinstance(ok, bool):
                success_flags.append(ok)
            # allow 'latency_ms' or 'latency' numeric
            lat = pl.get("latency_ms", pl.get("latency"))
            if isinstance(lat, (int, float)):
                latencies.append(float(lat))

    succ_ratio = (sum(1 for x in success_flags if x) / len(success_flags) * 100.0) if success_flags else None
    lat_avg = statistics.fmean(latencies) if latencies else None

    summary = doc.get("summary") or {}
    return {
        "date_utc": doc.get("date_utc"),
        "success_ratio_pct": round(succ_ratio, 2) if succ_ratio is not None else None,
        "latency_avg_ms": round(lat_avg, 2) if lat_avg is not None else None,
        "height": summary.get("height"),
        "current_supply": summary.get("current_supply"),
        "total_supply": summary.get("total_supply"),
        "coin_hours": summary.get("coin_hours"),
        "count_payloads": len(success_flags) if success_flags else 0,
    }

def md_report(metrics: Dict[str, Any]) -> str:
    d = metrics
    def fmt(x, suffix=""):
        return f"{x}{suffix}" if x is not None else "-"

    lines = [
        "# Skywire Vital Report",
        "",
        f"Last measurement: {d.get('date_utc') or datetime.date.today().isoformat()}",
        "",
        "## Daily Summary",
        f"* Success ratio : {fmt(d.get('success_ratio_pct'), ' %')}",
        f"* Latency avg   : {fmt(d.get('latency_avg_ms'), ' ms')}",
        f"* Nodes active (est.) : -",
        f"* Proxy activity (tx) : -",
        "",
        "> Auto-generated by Sigma – Skywire Vital Report.",
        ""
    ]
    return "\n".join(lines)

def sigma_transform(doc: Dict[str, Any], metrics: Dict[str, Any]) -> Dict[str, Any]:
    """Produce a minimal, stable Sigma analysis JSON."""
    return {
        "date_utc": metrics.get("date_utc"),
        "engine": "sigma-v1",
        "inputs": {
            "source": doc.get("meta", {}).get("source", "unknown"),
            "payloads": metrics.get("count_payloads", 0),
        },
        "features": {
            "success_ratio_pct": metrics.get("success_ratio_pct"),
            "latency_avg_ms": metrics.get("latency_avg_ms"),
            "supply": {
                "height": metrics.get("height"),
                "current": doc.get("summary", {}).get("current_supply"),
                "total": doc.get("summary", {}).get("total_supply"),
                "coin_hours": doc.get("summary", {}).get("coin_hours"),
            },
        },
        "generated_utc": datetime.datetime.utcnow().isoformat() + "Z",
    }

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--in", dest="inp", required=True)
    ap.add_argument("--out", dest="out_json", required=True)
    ap.add_argument("--md", dest="out_md", required=True)
    ap.add_argument("--sigma", dest="out_sigma", required=True)
    args = ap.parse_args()

    raw = read_json(args.inp)
    clean = sanitize_payload(raw)
    write_json(clean, args.out_json)

    m = metrics_from(clean)
    write_text(md_report(m), args.out_md)

    sig = sigma_transform(clean, m)
    write_json(sig, args.out_sigma)

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"[bridge] error: {e}", file=sys.stderr)
        sys.exit(1)
